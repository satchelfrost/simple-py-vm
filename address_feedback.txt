1) Addressing the subset of Python
----------------------------------
Though it's probably an oversimplification, I will define the subset of Python as
being the implementation of the visitor methods listed below.
This is also a convenient grading metric as well.

visit_Module(self, node : ast.Module): <-- this is only necessary because it's always the top level node
visit_Constant(self, node : ast.Constant):
visit_Name(self, node : ast.Name):
visit_FunctionDef(self, node : ast.FunctionDef):
visit_Return(self, node : ast.Return):
visit_Call(self, node : ast.Call):
visit_Assign(self, node : ast.Assign):
visit_While(self, node : ast.For):
visit_If(self, node : ast.If):
visit_Expr(self, node : ast.Expr):
visit_BinOp(self, node : ast.BinOp):
    visit_Add(self, node : ast.Add):
    visit_Sub(self, node : ast.Sub):
    visit_And(self, node : ast.And):
    visit_BitAnd(self, node : ast.BitAnd):
    visit_Or(self, node : ast.Or):
    visit_BitOr(self, node : ast.BitOr):
    visit_BitXor(self, node : ast.BitXor):
    visit_Mult(self, node : ast.Mult):
    visit_Div(self, node : ast.Div):
visit_Compare(self, node : ast.Compare):
    visit_Lt(self, node : ast.Lt):
    visit_LtE(self, node : ast.LtE):
    visit_Gt(self, node : ast.Gt):
    visit_GtE(self, node : ast.GtE):
    visit_Eq(self, node : ast.Eq):
    visit_NotEq(self, node : ast.NotEq):

2) Specifying the bytecode
--------------------------
I'm basing the bytecode instructions directly off of section III from the book: crafting interpreters
(https://craftinginterpreters.com/a-bytecode-virtual-machine.html) where he implements a bytecode virtual machine.
I will use as many of those instructions as are needed to implement the aforementioned visitor methods.
Before, I mentioned I would "design" the instructions myself, but taking a second look, it makes more sense just to implement his design
(but instead of C use Python since I'm using the `ast` module).

The basic idea is that The VM gets initialized with some number of so-called "chunks". The VM interprets each chunk by
setting the current chunk and instruction pointer. The chunk itself contains the bytecode, along with some constants.
The actual instructions in the chunk are variable length, so depending on the opcode, the instruction might be bigger or smaller.

Here is an example chunk containing two instructions totaling three bytes. The first is a return instruction which 
is only a single byte containing just the opcode. The second is a constant instruction, consisting of one byte for the
opcode and one byte for the index into the constant array.

------
| 01 | <-- opcode for return
------
------
| 00 | <-- opcode for constant
------
------
| 23 | <-- index into the constant array stored in the chunk
------

The general structure for the bytecode is as follows:
------
| X0 | <-- opcode for some arbitrary instruction
------
  .
  .
  .
------
| XN | <-- zero or more bytes following the opcode that specify the instruction
------

In theory, there should be at least one instruction for each of the nodes in the visitor methods.
